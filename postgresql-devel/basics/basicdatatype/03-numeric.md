There are several numeric types available in Postgres. They differ from each 
other with respect to numeric range and storage size (for integers), or 
precision (for decimals).

As in any other programming language, defining a type as numeric (as opposed to
 character/text) allows you to perform mathematical operations on stored values.

### Integers

The following character types store whole numbers:

| Name | Description | Range | Storage Size  |
|---|---|---|---|
| smallint  | small-range integer  | -32768 to +32767  | 2 bytes   |
| integer  |   | -2147483648 to +2147483647  | 4 bytes  |
| bigint  | large-range integer  | -9223372036854775808 to +9223372036854775807  | 8 bytes  |

`integer` is the most commonly used, while `bigint` is used when the `integer` 
range is too small.

Serials (`smallserial`, `serial`, `bigserial`) are not _true_ types in the 
sense that they're shorthand notation, telling Postgres that the column is an 
`integer` type, and to then create a unique identifier that _autoincrements_. 
This is a Postgres-specific method. Another way to accomplish this result that 
is in standard SQL is to use an [_identity_ column](https://www.postgresql.org/docs/current/sql-createtable.html).  

The CREATE TABLE statements in this course use identity columns to store IDs, 
using the `GENERATED BY DEFAULT AS IDENTITY` syntax. Take a look at this [blog 
post](https://www.2ndquadrant.com/en/blog/postgresql-10-identity-columns/) to 
see why identity columns have become the preferred method over `serial`.

### Numeric vs. decimal vs. real...

Use `numeric` with non-whole numbers, where **exactness** is required. Here's 
the syntax for declaring this type:

```
NUMERIC(precision, scale)
```

* `precision` is a positive integer that specifies the total count of digits in
 the number, including numbers on both sides of the decimal.

* `scale` is either 0 or a positive integer that indicates the count of digits 
to the right of the decimal.

Declaring `NUMERIC` without a specified precision nor scale will allow the 
column to store values of any precision and scale.

`decimal` is functionally the same as `numeric` in Postgres. They are both part
 of the SQL standard. 

The `real` and `double precision` types are **approximate** numeric types. This
 means that storing and outputing a value might show slight discrepancies.

### Add numeric values to a table

Let's try creating a new table with numeric columns and populating it with a 
 few values:

```
CREATE TABLE numtable (
    id serial PRIMARY KEY,
    number1 integer, 
    number2 numeric(16,8)
);

INSERT INTO numtable (number1, number2)
VALUES  (55, 110),
        (202004, 40.200),
        (1510, 33.6),
        (4132, 2.75314769)
;

SELECT * FROM numtable;
```{{execute}}

You'll see that some of the values under `number2` were _coerced_ to the 
indicated scale.

### Try a mathematical operation

Let's try to multiply two values from `texttable`:

```
SELECT 
    (SELECT chara1 FROM texttable WHERE id = 1) 
    * (SELECT chara1 FROM texttable WHERE id = 2)
;
```{{execute}}

The error message we get back implies that the operation isn't allowed for that
 data type (`char`).

But if we try it with numeric values from `numtable`:

```
SELECT 
    (SELECT number1 FROM numtable WHERE id = 1) 
    * (SELECT number1 FROM numtable WHERE id = 2)
;
```{{execute}}

We do get a numeric value as a result:

```
---------
11110220
```

### Note on numerics

There are storage and performance implications with numeric data types. For 
instance, calculations on `numeric` are slower than on the floating-point types
 `real` and `double precision`. But as mentioned earlier, floating-point types 
 don't guarantee exactness. You'll have to understand your data storage and 
 processing needs and weigh your options for numeric types carefully.

### Monetary values

While `money` is a data type included in Postgres, the advice you'll see more 
frequently is to use `numeric`. 

The way `money` works with a Postgres database depends on the _locale_, which 
is configured with the [`lc_monetary` client configuration setting](https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-LC-MONETARY). 
This determines what currency the `money` values are associated with, as well 
as their fractional precision. More details on the implementation can be found 
in the [official docs](https://www.postgresql.org/docs/current/datatype-money.html).
Note that `money` can also be cast to `numeric` and vice versa; conversion to 
and from other types such as `real` is also technically possible but requires 
intermediate steps. You might also run into rounding errors or loss in 
precision.

Additionally, if you ever change the locale or underlying currency setting, 
existing monetary values don't get updated or converted.

If you're only ever going to work with a single currency, and won't be going 
beyond simple mathematical operations such as addition or subtraction, `money` 
might be a good option since it can boost performance. Otherwise, sticking to 
`numeric` is recommended.
