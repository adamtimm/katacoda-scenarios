Enumerated types give you the ability to define an acceptable set of values 
that will be stored in the column, without the overhead of setting up a 
separate reference table.

In our example, we've decided to use an enum type to denote how events are 
conducted. You can think of dropdown lists, or anything with a "predefined" 
list of options, as good use cases for enums.

### Using the enum type

The syntax for declaring enums is a little different, consisting of:

1. The `CREATE TYPE` statement, and
2. Specifying the name of the created enum type in the table definition

Let's review what we did for the `event` table:

```
CREATE TYPE event_mode AS ENUM ('Virtual', 'In-person');

CREATE TABLE event (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name TEXT NOT NULL,
    event_dt tstzrange NOT NULL,
    mode event_mode NOT NULL
);
```

We've indicated that the `mode` field will store either 'In-person' or 'Virtual'.

If we try to add a record with a `mode` value that isn't included in the 
`event_mode` enum set, we get an error:

```
INSERT INTO event (name, event_dt, mode)
VALUES ('New Event', 
        tstzrange('2019-12-21 12:00:00 EST', '2019-12-21 17:00:00 EST', '[)'),
        'In person'        
);
```{{execute}}

 >ERROR: invalid input value for enum event_mode: "In person"

Notice that the only thing wrong is that `'In person'` is missing the `-`. 
You'll also get the same error if you try it with `'IN-PERSON'`. In a way, 
enums kind of function as constraints and can help ensure you have clean data.

### Enum or reference table or constraint?

In relational database design, it's common to have reference or "lookup" tables
 that contain a list of codes or values that are used in other tables. In our 
 business scenario, we could actually have a separate `event_mode` table that 
 the `event` table would reference. 

While it might be nice to not have to deal with the "overhead" of having 
separate lookup tables, you do lose a little bit of flexibility if you ever 
need to change an enum's list of values. For example, according to the 
[official docs](https://www.postgresql.org/docs/current/datatype-enum.html#id-1.5.7.15.8),
 "existing values cannot be removed from an enum type, nor can the sort 
 ordering of such values be changed, short of dropping and re-creating the enum
  type." Meanwhile, creating, updating, and deleting values from lookup 
  tables are more straightforward.

Enums might be better suited for a set of acceptable values that you're sure will 
never change. Even so, using enums versus reference tables could also come down
 to just a matter of preference.

Yet another option is to create a CHECK constraint for the list of values. This
 does require setting the constraint in every table definition that needs it. 
 CHECK constraints can't be modified, so if you need to update one, you would 
 have to drop the current constraint and add a new one.

The choices should ultimately be weighed against your business needs and 
processes.

### Links to official documentation

[postgresql.org: Enumerated Types](https://www.postgresql.org/docs/current/datatype-enum.html)  
[postgresql.org: Enum Support Functions](https://www.postgresql.org/docs/current/functions-enum.html)
